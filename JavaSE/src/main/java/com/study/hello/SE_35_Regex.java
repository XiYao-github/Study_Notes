package com.study.hello;

/*  正则表达式
    ()      标记一个子表达式的开始和结束位置
    (?i)	忽略后面字符的大小写
    (?i)abc	忽略abc的大小写
	[]      匹配括号内的任意一个字符
	[abc]   匹配abc之间的任意字母
	[^abc]  匹配abc之外的任何字符
	[a-z]   匹配a-z之间的全部字母
	&&      交集：表示逻辑或操作，不能写单个的&，例如[a-z&&m-p]
	|       并集：写在方括号外面表示并集，可以匹配多个模式中的任意一个，例如(cat|dog)，同时匹配"cat"或"dog"
	.       匹配任意字符(除了换行符)
	\       匹配特殊字符本身
	\d	    匹配一个数字：[0-9]
	\D	    匹配一个非数字： [^0-9]
	\s	    匹配一个空白字符：[ (空格)\f(换页)\n(换行)\r(回车)\t(制表符)\v(垂直制表符)]
	\S	    匹配一个非空白字符：[^ \f\n\r\t\v]
	\w	    匹配一个(字母、数字、下划线):[A-Za-z0-9_]
	\W	    匹配一个非(字母、数字、下划线):[^A-Za-z0-9_]

	限定符(配合匹配多个字符)
	?       匹配零次或一次
	*       匹配零次或多次
	+       匹配一次或多次
	{n}     匹配正好n次
	{n,}    匹配至少n次
	{n,m}   匹配至少n次且不超过m次

	定位符
	^   匹配输入字符串开始的位置
	$   匹配输入字符串结尾的位置
	\b  匹配一个单词边界部分：例如，'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'
	\B  匹配一个单词非边界部分：例如，'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'

	运算符优先级(相同优先级的从左到右进行运算，不同优先级的运算先高后低)
	\	                                转义符
    (), (?:), (?=), []	                圆括号和方括号
    *, +, ?, {n}, {n,}, {n,m}          	限定符
    ^, $, \任何元字符、任何字符	            定位点和序列（即：位置和顺序）
    |	                                替换，"或"操作，字符具有高于替换运算符的优先级，使得"m|food"匹配"m"或"food"。若要匹配"mood"或"food"，请使用括号创建子表达式，从而产生"(m|f)ood"。
    运算符优先级从高到低的顺序
    转义符号： \ 是用于转义其他特殊字符的转义符号。它具有最高的优先级。 示例：\d、\. 等，其中 \d 匹配数字，\. 匹配点号。
    括号： 圆括号 () 用于创建子表达式，具有高于其他运算符的优先级。 示例：(abc)+ 匹配 "abc" 一次或多次。
    量词： 量词指定前面的元素可以重复的次数。 示例：a* 匹配零个或多个 "a"。
    字符类： 字符类使用方括号 [] 表示，用于匹配括号内的任意字符。 示例：[aeiou] 匹配任何一个元音字母。
    断言： 断言是用于检查字符串中特定位置的条件的元素。 示例：^ 表示行的开头，$ 表示行的结尾。
    连接： 连接在没有其他运算符的情况下表示字符之间的简单连接。 示例：abc 匹配 "abc"。
    管道： 管道符号 | 表示"或"关系，用于在多个模式之间选择一个。 示例：cat|dog 匹配 "cat" 或 "dog"。

    反向引用：略
    修饰符：略
	*/
public class SE_35_Regex {
    // public boolean matches(String regex)断是否匹配指定的正则表达式
    // public String replaceAll(String regex, String replacement)替换满足正则表达式的所有字符为replacement
    // public String replaceFirst(String regex, String replacement)替换满足正则表达式的第一个字符为replacement
    // public String[] split(String regex)根据正则表达式拆分
    // public String[] split(String regex, int limit)根据正则表达式拆分，从指定的索引开始拆分
}
